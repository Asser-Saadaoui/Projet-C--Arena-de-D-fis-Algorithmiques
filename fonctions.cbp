#include "projet.h"

// UTILITAIRES CONSOLE 
void nettoyerEcran() {
    #ifdef _WIN32
        system("cls");
    #else
        system("clear");
    #endif
}

void banniere(const char* titre) {
    nettoyerEcran();
    printf(KBLU "################################################\n");
    printf("# %-44s #\n", titre);
    printf("################################################\n" KNRM);
    printf("\n");
}

void viderBuffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF) {}
}

int lireEntier(const char* message) {
    int nombre;
    int retour;
    do {
        printf("%s : ", message);
        retour = scanf("%d", &nombre);
        if (retour != 1) {
            printf(KRED "Erreur : Veuillez entrer un nombre valide.\n" KNRM);
            viderBuffer();
        }
    } while (retour != 1);
    return nombre;
}

void pause() {
    printf("\nAppuyez sur Entree pour continuer...");
    viderBuffer();
    getchar();
}

// 
//  GESTION DE LA LISTE CHAINEE (DEFI 1) 
// 

// Ajoute un nouveau noeud en tete 
NoeudNombre* ajouterNoeud(NoeudNombre* tete, int valeur) {
    NoeudNombre* nouveau = (NoeudNombre*)malloc(sizeof(NoeudNombre));
    if (nouveau == NULL) {
        perror("Erreur d'allocation memoire");
        exit(EXIT_FAILURE);
    }
    nouveau->valeur = valeur;
    nouveau->suivant = tete;
    return nouveau;
}

// Supprime un noeud specifique (le premier trouve)
NoeudNombre* supprimerNoeud(NoeudNombre* tete, int valeur_a_supprimer, bool* trouve) {
    *trouve = false;
    if (tete == NULL) return NULL;

    // Si le noeud a supprimer est la tete
    if (tete->valeur == valeur_a_supprimer) {
        NoeudNombre* nouveau_tete = tete->suivant;
        free(tete);
        *trouve = true;
        return nouveau_tete;
    }

    // Parcourir la liste pour trouver le predecesseur
    NoeudNombre* courant = tete; // Declaration et initialisation verifiees
    while (courant->suivant != NULL && courant->suivant->valeur != valeur_a_supprimer) {
        courant = courant->suivant;
    }

    // Si la valeur a ete trouvee
    if (courant->suivant != NULL) {
        NoeudNombre* a_supprimer = courant->suivant;
        courant->suivant = a_supprimer->suivant;
        free(a_supprimer);
        *trouve = true;
    }

    return tete;
}

// Nettoyage de la memoire
void libererListe(NoeudNombre* tete) {
    NoeudNombre* courant = tete; // Declaration et initialisation verifiees
    while (courant != NULL) {
        NoeudNombre* prochain = courant->suivant;
        free(courant);
        courant = prochain;
    }
}

// 
// GESTION DE L'ARBRE BINAIRE DE RECHERCHE (CLASSEMENT) 
// 

// Charge le classement depuis le fichier et construit l'ABR
NoeudJoueur* chargerClassement() {
    FILE *f = fopen(FICHIER_SCORE, "r");
    if (f == NULL) return NULL;

    NoeudJoueur* racine = NULL;
    char nom[MAX_NOM];
    int score;

    while (fscanf(f, "%s %d", nom, &score) != EOF) {
        racine = insererJoueur(racine, nom, score);
    }
    fclose(f);
    return racine;
}

// Insere un joueur dans l'ABR (trie par score descendant)
NoeudJoueur* insererJoueur(NoeudJoueur* racine, const char* nom, int score) {
    if (racine == NULL) {
        NoeudJoueur* nouveau = (NoeudJoueur*)malloc(sizeof(NoeudJoueur));
        if (nouveau == NULL) {
            perror("Erreur d'allocation memoire ABR");
            exit(EXIT_FAILURE);
        }
        strcpy(nouveau->nom, nom);
        nouveau->score = score;
        nouveau->gauche = nouveau->droite = NULL;
        return nouveau;
    }

    if (score > racine->score) {
        racine->gauche = insererJoueur(racine->gauche, nom, score);
    } else if (score < racine->score || (score == racine->score && strcmp(nom, racine->nom) < 0)) {
        racine->droite = insererJoueur(racine->droite, nom, score);
    }

    return racine;
}

// Affichage du classement (parcours In-Order inverse pour trier par score decroissant)
void afficherClassementTrie(NoeudJoueur* racine) {
    if (racine != NULL) {
        afficherClassementTrie(racine->droite);
        printf("%-20s | %d pts\n", racine->nom, racine->score);
        afficherClassementTrie(racine->gauche);
    }
}

// Fonction utilitaire pour la sauvegarde (Parcours In-Order classique)
void sauvegarderJoueur(NoeudJoueur* noeud, FILE* f) {
    if (noeud != NULL) {
        sauvegarderJoueur(noeud->gauche, f);
        fprintf(f, "%s %d\n", noeud->nom, noeud->score);
        sauvegarderJoueur(noeud->droite, f);
    }
}

// Sauvegarde l'ABR dans le fichier
void sauvegarderClassement(NoeudJoueur* racine) {
    FILE *f = fopen(FICHIER_SCORE, "w");
    if (f == NULL) {
        printf("Erreur lors de l'ouverture du fichier de scores pour sauvegarde.\n");
        return;
    }
    sauvegarderJoueur(racine, f);
    fclose(f);
}

// Liberation de la memoire ABR
void libererABR(NoeudJoueur* racine) {
    if (racine != NULL) {
        libererABR(racine->gauche);
        libererABR(racine->droite);
        free(racine);
    }
}

// --- DEFI 1 : Le Compte est Bon (Version Facile avec Message Final) ---
int defi_LeCompteEstBon_Interactif() {
    banniere("DEFI 1 : LE COMPTE EST BON (LISTE CHAINEE)");

    int nombres_fixes[6];

    // 1. GENERATION DE NOMBRES ALEATOIRES (1-100)
    for(int i=0; i<6; i++) {
        nombres_fixes[i] = (rand() % 100) + 1;
    }

    NoeudNombre* nombres_dispo_tete = NULL;
    int nb_restant = 6;
    for(int i=0; i<6; i++) {
        nombres_dispo_tete = ajouterNoeud(nombres_dispo_tete, nombres_fixes[i]);
    }

    // 2. GENERATION DE LA CIBLE (Robuste et garantie d'atteinte)
    int resultat_intermediaire[6];
    for(int i=0; i<6; i++) resultat_intermediaire[i] = nombres_fixes[i];
    int nb_constructif = 6;
    int cible_garantie = 0;
    int operations_faites = rand() % 3 + 3;

    for (int k = 0; k < operations_faites; k++) {
        if (nb_constructif < 2) break;

        int i1 = rand() % nb_constructif;
        int i2;
        do { i2 = rand() % nb_constructif; } while (i1 == i2);

        int op = rand() % 4 + 1;
        int res = 0;
        bool operation_valide = false;

        if (op == 4 && resultat_intermediaire[i2] != 0 && resultat_intermediaire[i1] % resultat_intermediaire[i2] == 0) {
            res = resultat_intermediaire[i1] / resultat_intermediaire[i2];
            operation_valide = true;
        } else if (op == 2 && resultat_intermediaire[i1] > resultat_intermediaire[i2]) {
            res = resultat_intermediaire[i1] - resultat_intermediaire[i2];
            operation_valide = true;
        } else if (op == 3) {
            res = resultat_intermediaire[i1] * resultat_intermediaire[i2];
            operation_valide = true;
        } else if (op == 1) {
            res = resultat_intermediaire[i1] + resultat_intermediaire[i2];
            operation_valide = true;
        }

        if (operation_valide && res > 0 && res < 1000) {
             resultat_intermediaire[i1] = res;
             resultat_intermediaire[i2] = resultat_intermediaire[nb_constructif - 1];
             nb_constructif--;
             cible_garantie = res;
        } else {
             k--;
        }
    }

    if (cible_garantie < 100 || cible_garantie > 999) {
        cible_garantie = (nombres_fixes[4] * nombres_fixes[5]) % 899 + 100;
    }

    int cible = cible_garantie;

    printf("Nombres de depart (Liste initiale) : ");
    for(int i=0; i<6; i++) printf("[%d] ", nombres_fixes[i]);
    printf("\nCible a atteindre : " KRED "%d" KNRM "\n", cible);

    int score_obtenu = 0;

    while (nb_restant > 1) {

        printf(KCYN "\n=== ETAT ACTUEL | Nombres Restants (%d) ===\n" KNRM, nb_restant);
        printf("Valeurs disponibles : ");

        NoeudNombre* courant = nombres_dispo_tete;
        while(courant != NULL) {
            printf(" %d ", courant->valeur);

            // Verification rapide de la cible si elle est deja dans la liste
            if (courant->valeur == cible) {
                printf(KGRN "\n[SUCCES] Felicitations ! Cible (%d) atteinte !\n" KNRM, cible);
                // Score : 100 points
                score_obtenu = 100;
                libererListe(nombres_dispo_tete);
                return score_obtenu;
            }
            courant = courant->suivant;
        }
        printf("\n\n");

        // GESTION DE LA SORTIE ET SAISIE (inchangé)
        char expression[20];
        printf("Entrez l'operation (ex: 8*9) ou tapez " KYEL "quit" KNRM " : ");

        if (fgets(expression, sizeof(expression), stdin) == NULL) {
            continue;
        }

        expression[strcspn(expression, "\n")] = 0;

        if (strcmp(expression, "quit") == 0 || strcmp(expression, "quitter") == 0) {
            printf(KCYN "Abandon du defi. Retour au menu principal. Score: 0.\n" KNRM);
            libererListe(nombres_dispo_tete);
            return 0;
        }

        // Parsing et validation (inchangé)
        int val1 = 0, val2 = 0;
        char op = 0;

        for(int i=0; i<strlen(expression); i++) {
            if (expression[i] == '+' || expression[i] == '-' || expression[i] == '*' || expression[i] == '/') {
                op = expression[i];
                char s_val1[10];
                strncpy(s_val1, expression, i);
                s_val1[i] = '\0';
                val1 = atoi(s_val1);

                char s_val2[10];
                strcpy(s_val2, expression + i + 1);
                val2 = atoi(s_val2);
                break;
            }
        }

        if (op == 0) {
            printf(KRED "Erreur de format. Saisissez NOPN (ex: 8+9).\n" KNRM);
            pause(); continue;
        }

        bool trouve1 = false;
        bool trouve2 = false;

        NoeudNombre* temp_tete = nombres_dispo_tete;
        temp_tete = supprimerNoeud(temp_tete, val1, &trouve1);

        if (trouve1) {
             temp_tete = supprimerNoeud(temp_tete, val2, &trouve2);
        }

        if (!(trouve1 && trouve2)) {
            if (trouve1) {
                temp_tete = ajouterNoeud(temp_tete, val1);
            }
            nombres_dispo_tete = temp_tete;

            printf(KRED "Erreur: Nombres non disponibles ou utilisation double de la meme valeur sans duplication.\n" KNRM);
            pause(); continue;
        }

        nombres_dispo_tete = temp_tete;

        // Execution et Validation des Regles du Jeu (inchange)
        int resultat = 0;
        bool operation_valide = true;

        if (op == '+') {
            resultat = val1 + val2;
        } else if (op == '-') {
            if (val1 <= val2) { operation_valide = false; } else { resultat = val1 - val2; }
        } else if (op == '*') {
            resultat = val1 * val2;
        } else if (op == '/') {
            if (val2 == 0 || val1 % val2 != 0) { operation_valide = false; } else { resultat = val1 / val2; }
        }

        // Mise a jour de la sequence
        if (operation_valide) {
            printf(KYEL "-> Operation : %d %c %d = %d\n" KNRM, val1, op, val2, resultat);

            nombres_dispo_tete = ajouterNoeud(nombres_dispo_tete, resultat);
            nb_restant--;

            if (resultat == cible) {
                printf(KGRN "\n[SUCCES] Felicitations ! Cible (%d) atteinte !\n" KNRM, cible);
                score_obtenu = 100;
                libererListe(nombres_dispo_tete);
                return score_obtenu;
            }
        } else {
            // Restauration des nombres si l'operation est invalide
            nombres_dispo_tete = ajouterNoeud(nombres_dispo_tete, val1);
            nombres_dispo_tete = ajouterNoeud(nombres_dispo_tete, val2);
            printf(KRED "Operation invalide (Resultat negatif ou fraction). Nombres restaures.\n" KNRM);
        }
        pause();
    }

    // 
    // LOGIQUE FINALE : Le joueur n'a pas atteint la cible -> Score 0
    // 

    // Recherche du meilleur resultat pour l'affichage (informer le joueur)
    int meilleur_proche = 999999;
    NoeudNombre* courant_final = nombres_dispo_tete;
    while(courant_final != NULL) {
        int diff = abs(cible - courant_final->valeur);
        if (diff < meilleur_proche) {
            meilleur_proche = diff;
        }
        courant_final = courant_final->suivant;
    }

    printf(KRED "\n[ECHEC] Fin de partie. Cible (%d) non atteinte.\n" KNRM, cible);
    printf(KYEL "Votre meilleur resultat etait a %d de la cible. Score: 0.\n" KNRM, meilleur_proche);

    libererListe(nombres_dispo_tete);
    return 0; // Score 0 en cas d'echec
}

//  DEFI 2 : Mastermind (Correction de saisie stricte) 
int defi_Mastermind() {
    banniere("DEFI 2 : MASTERMIND ALGORITHMIQUE");
    int secret[4];
    for(int i=0; i<4; i++) secret[i] = rand() % 10;

    printf("Devinez le code secret de 4 chiffres (0-9).\n");
    printf("Vous avez 10 essais.\n");

    for(int coup=1; coup<=10; coup++) {
        char saisie[10];
        int tentative = -1;
        bool saisieValide = false; // Flag pour valider la saisie stricte

        do {
            printf("\nEssai %d/10. ", coup);
            printf("Votre code (ex: 1234) ou tapez " KYEL "quit" KNRM " : ");

            if (fgets(saisie, sizeof(saisie), stdin) == NULL) {
                continue;
            }
            saisie[strcspn(saisie, "\n")] = 0; // Supprime le saut de ligne
            saisieValide = false; // Réinitialise le flag

            // 1. Vérification de la commande de sortie
            if (strcmp(saisie, "quit") == 0 || strcmp(saisie, "quitter") == 0) {
                 printf(KCYN "Abandon du defi. Retour au menu principal.\n" KNRM);
                 return 0;
            }

            // 2. Vérification de la longueur stricte
            if (strlen(saisie) != 4) {
                printf(KRED "ATTENTION : Le code doit contenir EXACTEMENT 4 chiffres (ex: 0123).\n" KNRM);
                continue; // Recommence la boucle do-while
            }

            // 3. Vérification que tous les caractères sont des chiffres
            saisieValide = true;
            for (int i = 0; i < 4; i++) {
                if (saisie[i] < '0' || saisie[i] > '9') {
                    printf(KRED "Erreur : La saisie ne doit contenir que des chiffres (0-9).\n" KNRM);
                    saisieValide = false;
                    break;
                }
            }

            // 4. Si la chaîne est valide, la convertir en entier
            if (saisieValide) {
                 tentative = atoi(saisie); // Convertit "1234" en 1234
            } else {
                 tentative = -1; // Force la continuité de la boucle do-while
            }

        } while (!saisieValide); // La boucle continue tant que la saisie n'est pas strictement valide

        // Le code de jeu original continue ici, car 'tentative' est maintenant un entier
        // de 0 à 9999 correspondant exactement à 4 chiffres (incluant les zéros initiaux).

        int tempGuess[4];
        // Extraction des chiffres, y compris les zéros initiaux si 'tentative' vient de 'atoi("0123")'
        tempGuess[3] = tentative % 10;
        tempGuess[2] = (tentative/10) % 10;
        tempGuess[1] = (tentative/100) % 10;
        tempGuess[0] = (tentative/1000) % 10;

        int bienPlaces = 0;
        int malPlaces = 0;

        int copieSecret[4];
        int copieGuess[4];
        for(int k=0; k<4; k++) { copieSecret[k] = secret[k]; copieGuess[k] = tempGuess[k]; }

        for(int i=0; i<4; i++) {
            if(copieGuess[i] == copieSecret[i]) {
                bienPlaces++;
                copieSecret[i] = -1;
                copieGuess[i] = -2;
            }
        }

        for(int i=0; i<4; i++) {
            if(copieGuess[i] == -2) continue;
            for(int j=0; j<4; j++) {
                if(copieSecret[j] != -1 && copieGuess[i] == copieSecret[j]) {
                    malPlaces++;
                    copieSecret[j] = -1;
                    break;
                }
            }
        }

        printf(" -> " KGRN "%d Bien places" KNRM ", " KYEL "%d Mal places\n" KNRM, bienPlaces, malPlaces);

        if(bienPlaces == 4) {
            printf(KGRN "\nBRAVO ! Code trouve.\n" KNRM);
            return 100 - (coup * 5);
        }
    }
    printf(KRED "Echec. Le code etait : %d%d%d%d\n" KNRM, secret[0], secret[1], secret[2], secret[3]);
    return 0;
}

//  DEFI 3 : Labyrinthe (Mode Défi Algorithmique) 
#define TAILLE_LABY 10

void genererLabyrinthe(int map[TAILLE_LABY][TAILLE_LABY]) {
    // Initialisation : Murs partout (1)
    for (int i = 0; i < TAILLE_LABY; i++) {
        for (int j = 0; j < TAILLE_LABY; j++) {
            map[i][j] = 1;
        }
    }

    // Stack pour la methode DFS
    int stack[100][2]; // Pile pour stocker les coordonnées
    int top = 0;

    // Début : Point (1, 1) est le départ
    int px = 1, py = 1;
    map[px][py] = 2; // Marqueur de départ (2)

    stack[top][0] = px;
    stack[top][1] = py;
    top++;

    // Mouvements possibles (de 2 cases pour sauter le mur)
    int dx[] = {-2, 2, 0, 0};
    int dy[] = {0, 0, -2, 2};

    while (top > 0) {
        // Pop de la pile
        top--;
        px = stack[top][0];
        py = stack[top][1];

        // Créer un tableau d'indices de direction et les mélanger
        int directions[] = {0, 1, 2, 3};
        for (int i = 0; i < 4; i++) {
            int j = rand() % 4;
            int temp = directions[i];
            directions[i] = directions[j];
            directions[j] = temp;
        }

        // Essayer les directions melangees
        for (int i = 0; i < 4; i++) {
            int dir = directions[i];
            int nx = px + dx[dir];
            int ny = py + dy[dir];

            // Verifier si la nouvelle position est valide et encore mur (1)
            if (nx > 0 && nx < TAILLE_LABY - 1 && ny > 0 && ny < TAILLE_LABY - 1 && map[nx][ny] == 1) {
                // Percer le mur au milieu (Chemin = 0)
                map[px + dx[dir] / 2][py + dy[dir] / 2] = 0;

                // Percer la nouvelle cellule (Chemin = 0)
                map[nx][ny] = 0;

                // Pousser la nouvelle position sur la pile
                stack[top][0] = nx;
                stack[top][1] = ny;
                top++;
            }
        }
    // Assurer que le depart est en (1, 1)
    map[1][1] = 2;

    // Placer la sortie (3) aleatoirement sur un chemin (0), hors du depart
    int ex, ey;
    do {
        ex = rand() % (TAILLE_LABY - 2) + 1;
        ey = rand() % (TAILLE_LABY - 2) + 1;
    } while (map[ex][ey] != 0 || (ex == 1 && ey == 1));
    map[ex][ey] = 3;
    }
}

// DEFI 3 : Labyrinthe (Mode Defi Algorithmique) 
int defi_Labyrinthe() {
    banniere("DEFI 3 : COURSE DE ROBOT - MODE EXPERT");
    int map[TAILLE_LABY][TAILLE_LABY];

    // Genere un nouveau labyrinthe a chaque appel
    genererLabyrinthe(map);

    int px_start = 1, py_start = 1;
    int ex = -1, ey = -1; // Position de la sortie

    // Pour gerer la boucle de saisie
    char chemin_saisi[200];
    int score_obtenu = 0;
    bool defi_termine = false;

    //  AFFICHAGE INITIAL ET RECHERCHE DES POINTS DE DEPART/ARRIVEE 
    nettoyerEcran();
    printf("=== LABYRINTHE EXPERT ===\n");
    printf(KYEL "Objectif : Entrer le chemin complet (N, S, E, O) le plus court possible.\n" KNRM);

    for(int i=0; i<TAILLE_LABY; i++) {
        for(int j=0; j<TAILLE_LABY; j++) {
            if(map[i][j]==2) {
                printf(KCYN "R " KNRM); // Depart (R)
                px_start = i; py_start = j;
            }
            else if(map[i][j]==3) {
                printf(KGRN "E " KNRM); // Sortie (E)
                ex = i; ey = j;
            }
            else if(map[i][j]==1) printf("# "); // Mur (#)
            else printf(". ");                  // Chemin (.)
        }
        printf("\n");
    }

    while (!defi_termine) {

        printf("\nEntrez votre chemin (ex: NNESSO) ou " KYEL "quit" KNRM " : ");

        if (fgets(chemin_saisi, sizeof(chemin_saisi), stdin) == NULL) continue;
        chemin_saisi[strcspn(chemin_saisi, "\n")] = 0;

        // Gestion de l'abandon
        if (strcmp(chemin_saisi, "quit") == 0 || strcmp(chemin_saisi, "quitter") == 0) {
            printf(KCYN "Abandon du defi. Score: 0.\n" KNRM);
            pause();
            return 0;
        }

        //  ANALYSE ET EXECUTION DU CHEMIN 
        int px = px_start;
        int py = py_start;
        int coups = 0;
        bool chemin_valide = true;

        for (int i = 0; i < strlen(chemin_saisi); i++) {
            int nx = px, ny = py;
            char move = chemin_saisi[i];

            // Mappage des directions
            if(move=='n' || move=='N') nx--; // Nord (Haut)
            else if(move=='s' || move=='S') nx++; // Sud (Bas)
            else if(move=='o' || move=='O') ny--; // Ouest (Gauche)
            else if(move=='e' || move=='E') ny++; // Est (Droite)
            else {
                printf(KRED "\nErreur : Caractere '%c' invalide dans le chemin au mouvement %d. Veuillez ressaisir.\n" KNRM, move, coups + 1);
                chemin_valide = false;
                break;
            }

            // Verification de la nouvelle position
            if(map[nx][ny] == 1) {
                printf(KRED "\nErreur : Le chemin touche un mur ('#') au mouvement %d. Veuillez ressaisir.\n" KNRM, coups + 1);
                chemin_valide = false;
                break;
            }

            // Mouvement reussi
            px = nx;
            py = ny;
            coups++;

            // Verification de la sortie
            if(map[px][py] == 3) {
                 break;
            }
        }

        //  GESTION DU RESULTAT 
        if (!chemin_valide) {
            pause();
            continue;
        }

        defi_termine = true;

        if (map[px][py] == 3) {
            printf(KGRN "\nSortie atteinte en %d mouvements !\n" KNRM, coups);

            int seuil_optimal = 25;

            if (coups <= seuil_optimal) {
                printf(KGRN "PERFORMANCE EXCEPTIONNELLE ! Chemin tres court.\n" KNRM);
                score_obtenu = 50;
            } else if (coups <= seuil_optimal + 10) {
                printf(KYEL "Bonne performance. Vous avez atteint la sortie.\n" KNRM);
                score_obtenu = 25;
            } else {
                printf(KRED "Chemin trop long. Ameliorez votre sequence. Score: 10.\n" KNRM);
                score_obtenu = 10;
            }
        } else {
            printf(KRED "\nEchec : Le chemin s'est termine a la position (%d, %d) sans atteindre la sortie (E).\n" KNRM, px, py);
            score_obtenu = 0;
        }
    }

    pause();
    return score_obtenu;
}

//  DEFI 4 : Tri Ultime 
int defi_TriUltime() {
    banniere("DEFI 4 : TRI ULTIME INTERACTIF");
    int tab[6];
    char buffer[100];

    // Initialisation du tableau avec des nombres aleatoires
    for(int i=0; i<6; i++) tab[i] = rand() % 50;

    int echanges = 0;

    printf("Objectif: Trier le tableau en un minimum d'echanges.\n");

    while(1) {
        int estTrie = 1;
        printf("\n--- Nombre d'echanges: %d ---\n", echanges);
        printf("Tableau (Indice utilisateur 1-6) : \n");

        for(int i=0; i<6; i++) {
            if(i < 5 && tab[i] > tab[i+1]) estTrie = 0;
            printf(" | %d: " KBLU "%d" KNRM, i + 1, tab[i]);
        }
        printf(" |\n");

         if(estTrie) {
            printf(KGRN "\nBRAVO ! Tableau trie en %d echanges !\n" KNRM, echanges);
            
            int score_attribue;

            if (echanges <= 5) {
                // Le joueur a atteint ou depasse la performance optimale (min 0, max 5)
                printf(KGRN "Performance EXCELLENTE (Optimal) !\n" KNRM);
                score_attribue = 100;
            } else if (echanges <=8) {
                // Correspond a l'ancien "Excellent", toujours tres bon.
                printf(KYEL "Performance TRES BONNE.\n" KNRM);
                score_attribue = 85;
            } else if (echanges <= 10) {
                // Performance moyenne.
                printf(KCYN "Performance BONNE.\n" KNRM);
                score_attribue = 50;
            } else if (echanges <= 12) {
                score_attribue = 20;
            } else {
                // Score minimum.
                score_attribue = 5; 
            }

            // On retire une petite penalite pour les echanges au dela du seuil optimal (5)
            if (echanges > 5) {
                // Pénalité = 5 points par échange au-delà des 5 premiers
                int penalite = (echanges - 5) * 5;
                if (score_attribue - penalite > 5) {
                    score_attribue -= penalite;
                }
            }

            // Assurer que le score ne soit pas negatif
            if (score_attribue < 0) score_attribue = 0; 

            printf(KCYN "Score final attribue: %d points.\n" KNRM, score_attribue);
            return score_attribue;
        }

        printf("\nEntrez les indices (1-6) de 2 cases a echanger (ex: 1 2) ou " KYEL "quit" KNRM " : ");

        if (fgets(buffer, sizeof(buffer), stdin) == NULL) continue;

        buffer[strcspn(buffer, "\n")] = 0;

        if (strcmp(buffer, "quit") == 0 || strcmp(buffer, "quitter") == 0) {
            printf(KCYN "Abandon du defi. Score: 0.\n" KNRM);
            return 0;
        }

        int i1_user, i2_user;

        if (sscanf(buffer, "%d %d", &i1_user, &i2_user) != 2) {
            printf(KRED "Erreur: Veuillez entrer deux indices separes par un espace (ex: 1 2).\n" KNRM);
            continue;
        }

        if (i1_user < 1 || i1_user > 6 || i2_user < 1 || i2_user > 6) {
            printf(KRED "Erreur: Les indices doivent etre compris entre 1 et 6.\n" KNRM);
            continue;
        }

        if (i1_user == i2_user) {
            printf(KRED "Erreur: Les deux indices doivent etre differents.\n" KNRM);
            continue;
        }

        int i1_tab = i1_user - 1;
        int i2_tab = i2_user - 1;

        int tmp = tab[i1_tab];
        tab[i1_tab] = tab[i2_tab];
        tab[i2_tab] = tmp;

        echanges++;
    }
}
// --- DEFI BONUS : Voyageur de Commerce (TSP) (AVEC BOUCLE DE CORRECTION) ---
int defi_VoyageurDeCommerce() {
    banniere("DEFI BONUS : VOYAGEUR DE COMMERCE (TSP)");

    #define NB_VILLES 5
    #define MAX_COORD 20
    #define SCORE_EXCELLENT 50
    #define SCORE_BON 20
    #define BUFFER_SIZE 20

    int villes[NB_VILLES][2];

    // Initialisation des villes
    for(int i=0; i<NB_VILLES; i++) {
        villes[i][0] = rand() % MAX_COORD;
        villes[i][1] = rand() % MAX_COORD;
    }

    printf("Trouvez l'ordre optimal pour visiter les %d villes (0 a %d) et minimiser la distance totale.\n", NB_VILLES, NB_VILLES - 1);

    // Affichage des villes avec leurs coordonnées
    printf(KCYN "--- VILLES A VISITER ---\n" KNRM);
    for(int i=0; i<NB_VILLES; i++) {
        printf("Ville %d : (%d, %d)\n", i, villes[i][0], villes[i][1]);
    }
    printf("\n");

    // --- CALCUL DES OBJECTIFS DE SCORE ---
    double distance_estimee = 0.0;
    for(int i=0; i < NB_VILLES - 1; i++) {
        int dx = abs(villes[i][0] - villes[i+1][0]);
        int dy = abs(villes[i][1] - villes[i+1][1]);
        distance_estimee += (double)(dx + dy);
    }

    double distance_optimale = distance_estimee * 0.8;

    printf(KYEL "Distance de reference (Ordre 01234) : %.0f\n" KNRM, distance_estimee);
    printf(KGRN "Objectif pour le score maximal (%d pts) : Viser une distance totale <= %.0f.\n" KNRM, SCORE_EXCELLENT, distance_optimale);


    // BOUCLE PRINCIPALE DE JEU ET DE CORRECTION DE SAISIE

    char buffer[BUFFER_SIZE];
    int score_obtenu = 0;
    bool defi_termine = false;

    while (!defi_termine) {

        printf("\nEntrez votre ordre de visite des villes (ex: 01234) ou " KYEL "quit" KNRM " : ");

        if (fgets(buffer, sizeof(buffer), stdin) == NULL) {
            continue;
        }
        buffer[strcspn(buffer, "\n")] = 0;

        // VÉRIFICATION quit ou quitter
        if (strcmp(buffer, "quit") == 0 || strcmp(buffer, "quitter") == 0) {
            printf(KCYN "Abandon du defi. Score: 0.\n" KNRM);
            defi_termine = true;
            continue;
        }


        // 1. VÉRIFICATION DE LA LONGUEUR
        if (strlen(buffer) != NB_VILLES) {
            printf(KRED "Erreur : L'ordre doit contenir exactement %d chiffres.\n" KNRM, NB_VILLES);
            pause(); continue; // Retourne en haut de la boucle
        }

        double distance_utilisateur = 0.0;
        int dernier_ville_idx = -1;
        bool ordre_valide = true;
        bool utilise[NB_VILLES] = {false};

        
        for(int i=0; i<NB_VILLES; i++) {

            // Verification si c'est un chiffre valide (0 à 4)
            if (buffer[i] < '0' || buffer[i] > ('0' + NB_VILLES - 1)) {
                 printf(KRED "Erreur : La saisie ('%c') n'est pas un chiffre valide de 0 a %d.\n" KNRM, buffer[i], NB_VILLES - 1);
                 ordre_valide = false;
                 break;
            }

            int ville_idx = buffer[i] - '0';

            // Verification d'unicite
            if (utilise[ville_idx]) {
                printf(KRED "Erreur : La ville %d a ete utilisee plus d'une fois. Chaque ville doit etre unique.\n" KNRM, ville_idx);
                ordre_valide = false;
                break;
            }
            utilise[ville_idx] = true;

            // CALCUL DE LA DISTANCE 
            if (dernier_ville_idx != -1) {
                int dx = abs(villes[dernier_ville_idx][0] - villes[ville_idx][0]);
                int dy = abs(villes[dernier_ville_idx][1] - villes[ville_idx][1]);
                distance_utilisateur += (double)(dx + dy);
            }
            dernier_ville_idx = ville_idx;
        } 

        // Si l'ordre est invalide, on revient en haut de la boucle pour redemander la saisie
        if (!ordre_valide) {
            pause();
            continue;
        }

        // Si l'ordre est valide, on termine le defi
        defi_termine = true;

        printf(KGRN "\nDistance totale calculee : %.0f\n" KNRM, distance_utilisateur);

        // --- SCORING FINAL ---
        if (distance_utilisateur <= distance_optimale) {
            printf(KGRN "PERFORMANCE EXCEPTIONNELLE ! Vous avez battu l'objectif.\n" KNRM);
            score_obtenu = SCORE_EXCELLENT;
        } else if (distance_utilisateur < distance_estimee) {
            printf(KYEL "Bonne performance ! Vous avez ameliore l'ordre de base.\n" KNRM);
            score_obtenu = SCORE_BON;
        } else {
            printf(KRED "Peut etre ameliore. Score: 0.\n" KNRM);
            score_obtenu = 0;
        }
    } (!defi_termine)

    pause();
    return score_obtenu;
}

